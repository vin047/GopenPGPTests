// Objective-C API for talking to github.com/ProtonMail/gopenpgp/crypto Go package.
//   gobind -lang=objc github.com/ProtonMail/gopenpgp/crypto
//
// File is generated by gobind. Do not edit.

#ifndef __Crypto_H__
#define __Crypto_H__

@import Foundation;
#include "ref.h"
#include "Universe.objc.h"

#include "Armor.objc.h"
#include "Constants.objc.h"
#include "Models.objc.h"

@class CryptoAttachmentProcessor;
@class CryptoGopenPGP;
@class CryptoIdentity;
@class CryptoKeyRing;
@class CryptoSignature;
@class CryptoSignatureCollector;
@class CryptoSignedString;
@class CryptoSymmetricKey;
@protocol CryptoMIMECallbacks;
@class CryptoMIMECallbacks;

@protocol CryptoMIMECallbacks <NSObject>
- (void)onAttachment:(NSString* _Nullable)headers data:(NSData* _Nullable)data;
- (void)onBody:(NSString* _Nullable)body mimetype:(NSString* _Nullable)mimetype;
- (void)onEncryptedHeaders:(NSString* _Nullable)headers;
- (void)onError:(NSError* _Nullable)err;
- (void)onVerified:(long)verified;
@end

/**
 * AttachmentProcessor keeps track of the progress of encrypting an attachment
(optimized for encrypting large files).
 */
@interface CryptoAttachmentProcessor : NSObject <goSeqRefInterface> {
}
@property(strong, readonly) _Nonnull id _ref;

- (nonnull instancetype)initWithRef:(_Nonnull id)ref;
- (nonnull instancetype)init;
/**
 * Finish closes the attachment and returns the encrypted data
 */
- (ModelsEncryptedSplit* _Nullable)finish:(NSError* _Nullable* _Nullable)error;
/**
 * Process writes attachment data to be encrypted
 */
- (void)process:(NSData* _Nullable)plainData;
@end

/**
 * GopenPGP is used as a "namespace" for many of the functions in this package.
It is a struct that keeps track of time skew between server and client.
 */
@interface CryptoGopenPGP : NSObject <goSeqRefInterface> {
}
@property(strong, readonly) _Nonnull id _ref;

- (nonnull instancetype)initWithRef:(_Nonnull id)ref;
- (nonnull instancetype)init;
/**
 * BuildKeyRing reads keyring from binary data
 */
- (CryptoKeyRing* _Nullable)buildKeyRing:(NSData* _Nullable)binKeys error:(NSError* _Nullable* _Nullable)error;
/**
 * BuildKeyRingArmored reads armored string and returns keyring
 */
- (CryptoKeyRing* _Nullable)buildKeyRingArmored:(NSString* _Nullable)key error:(NSError* _Nullable* _Nullable)error;
/**
 * BuildKeyRingNoError does not return error on fail
 */
- (CryptoKeyRing* _Nullable)buildKeyRingNoError:(NSData* _Nullable)binKeys;
/**
 * CheckKey is a debug helper function that prints the key and subkey
fingerprints.
 */
- (NSString* _Nonnull)checkKey:(NSString* _Nullable)pubKey error:(NSError* _Nullable* _Nullable)error;
- (NSData* _Nullable)decryptAttachment:(NSData* _Nullable)keyPacket dataPacket:(NSData* _Nullable)dataPacket kr:(CryptoKeyRing* _Nullable)kr passphrase:(NSString* _Nullable)passphrase error:(NSError* _Nullable* _Nullable)error;
/**
 * DecryptMIMEMessage decrypts a MIME message.
 */
- (void)decryptMIMEMessage:(NSString* _Nullable)encryptedText verifierKey:(CryptoKeyRing* _Nullable)verifierKey privateKeyRing:(CryptoKeyRing* _Nullable)privateKeyRing passphrase:(NSString* _Nullable)passphrase callbacks:(id<CryptoMIMECallbacks> _Nullable)callbacks verifyTime:(int64_t)verifyTime;
/**
 * DecryptMessage decrypts encrypted string using keyring
encryptedText : string armored encrypted
privateKey : keyring with private key to decrypt message, could be multiple keys
passphrase : match with private key to decrypt message
 */
- (NSString* _Nonnull)decryptMessage:(NSString* _Nullable)encryptedText privateKey:(CryptoKeyRing* _Nullable)privateKey passphrase:(NSString* _Nullable)passphrase error:(NSError* _Nullable* _Nullable)error;
/**
 * DecryptMessageStringKey decrypts encrypted message use private key (string)
encryptedText : string armored encrypted
privateKey : armored private use to decrypt message
passphrase : match with private key to decrypt message
 */
- (NSString* _Nonnull)decryptMessageStringKey:(NSString* _Nullable)encryptedText privateKey:(NSString* _Nullable)privateKey passphrase:(NSString* _Nullable)passphrase error:(NSError* _Nullable* _Nullable)error;
/**
 * DecryptMessageVerify decrypts message and verify the signature
encryptedText:  string armored encrypted
verifierKey    []byte: unarmored verifier keys
privateKeyRing []byte: unarmored private key to decrypt. could be multiple
passphrase:    match with private key to decrypt message
 */
- (ModelsDecryptSignedVerify* _Nullable)decryptMessageVerify:(NSString* _Nullable)encryptedText verifierKey:(CryptoKeyRing* _Nullable)verifierKey privateKeyRing:(CryptoKeyRing* _Nullable)privateKeyRing passphrase:(NSString* _Nullable)passphrase verifyTime:(int64_t)verifyTime error:(NSError* _Nullable* _Nullable)error;
/**
 * DecryptMessageWithPassword decrypts a pgp message with a password
encrypted string : armored pgp message
output string : clear text
 */
- (NSString* _Nonnull)decryptMessageWithPassword:(NSString* _Nullable)encrypted password:(NSString* _Nullable)password error:(NSError* _Nullable* _Nullable)error;
- (ModelsEncryptedSplit* _Nullable)encryptAttachment:(NSData* _Nullable)plainData fileName:(NSString* _Nullable)fileName publicKey:(CryptoKeyRing* _Nullable)publicKey error:(NSError* _Nullable* _Nullable)error;
- (CryptoAttachmentProcessor* _Nullable)encryptAttachmentLowMemory:(long)estimatedSize fileName:(NSString* _Nullable)fileName publicKey:(CryptoKeyRing* _Nullable)publicKey error:(NSError* _Nullable* _Nullable)error;
/**
 * EncryptMessage encrypts message with unarmored public key, if pass private key and passphrase will also sign
the message
publicKey : bytes unarmored public key
plainText : the input
privateKey : optional required when you want to sign
passphrase : optional required when you pass the private key and this passphrase should decrypt the private key
trim : bool true if need to trim new lines
 */
- (NSString* _Nonnull)encryptMessage:(NSString* _Nullable)plainText publicKey:(CryptoKeyRing* _Nullable)publicKey privateKey:(CryptoKeyRing* _Nullable)privateKey passphrase:(NSString* _Nullable)passphrase trim:(BOOL)trim error:(NSError* _Nullable* _Nullable)error;
/**
 * EncryptMessageWithPassword encrypts a plain text to pgp message with a password
plainText string: clear text
output string: armored pgp message
 */
- (NSString* _Nonnull)encryptMessageWithPassword:(NSString* _Nullable)plainText password:(NSString* _Nullable)password error:(NSError* _Nullable* _Nullable)error;
/**
 * GenerateKey generates a key of the given keyType ("rsa" or "x25519"). If
keyType is "rsa", bits is the RSA bitsize of the key. If keyType is "x25519",
bits is unused.
 */
- (NSString* _Nonnull)generateKey:(NSString* _Nullable)userName domain:(NSString* _Nullable)domain passphrase:(NSString* _Nullable)passphrase keyType:(NSString* _Nullable)keyType bits:(long)bits error:(NSError* _Nullable* _Nullable)error;
/**
 * GenerateRSAKeyWithPrimes generates a RSA key using the given primes.
 */
- (NSString* _Nonnull)generateRSAKeyWithPrimes:(NSString* _Nullable)userName domain:(NSString* _Nullable)domain passphrase:(NSString* _Nullable)passphrase bits:(long)bits primeone:(NSData* _Nullable)primeone primetwo:(NSData* _Nullable)primetwo primethree:(NSData* _Nullable)primethree primefour:(NSData* _Nullable)primefour error:(NSError* _Nullable* _Nullable)error;
/**
 * GetSessionFromKeyPacket returns the decrypted session key from a binary
public-key encrypted session key packet.
 */
- (CryptoSymmetricKey* _Nullable)getSessionFromKeyPacket:(NSData* _Nullable)keyPacket privateKey:(CryptoKeyRing* _Nullable)privateKey passphrase:(NSString* _Nullable)passphrase error:(NSError* _Nullable* _Nullable)error;
/**
 * GetSessionFromSymmetricPacket decrypts the binary symmetrically encrypted
session key packet and returns the session key.
 */
- (CryptoSymmetricKey* _Nullable)getSessionFromSymmetricPacket:(NSData* _Nullable)keyPacket password:(NSString* _Nullable)password error:(NSError* _Nullable* _Nullable)error;
// skipped method GopenPGP.GetTime with unsupported parameter or return types

/**
 * GetTimeUnix gets latest cached time
 */
- (int64_t)getTimeUnix;
/**
 * IsKeyExpired checks whether the given armored key is expired.
 */
- (BOOL)isKeyExpired:(NSString* _Nullable)publicKey ret0_:(BOOL* _Nullable)ret0_ error:(NSError* _Nullable* _Nullable)error;
/**
 * IsKeyExpiredBin checks whether the given (unarmored, binary) key is expired.
 */
- (BOOL)isKeyExpiredBin:(NSData* _Nullable)publicKey ret0_:(BOOL* _Nullable)ret0_ error:(NSError* _Nullable* _Nullable)error;
/**
 * KeyPacketWithPublicKey encrypts the session key with the armored publicKey
and returns a binary public-key encrypted session key packet.
 */
- (NSData* _Nullable)keyPacketWithPublicKey:(CryptoSymmetricKey* _Nullable)sessionSplit publicKey:(NSString* _Nullable)publicKey error:(NSError* _Nullable* _Nullable)error;
/**
 * KeyPacketWithPublicKeyBin encrypts the session key with the unarmored
publicKey and returns a binary public-key encrypted session key packet.
 */
- (NSData* _Nullable)keyPacketWithPublicKeyBin:(CryptoSymmetricKey* _Nullable)sessionSplit publicKey:(NSData* _Nullable)publicKey error:(NSError* _Nullable* _Nullable)error;
/**
 * RandomToken generates a random token with the key size of the default cipher.
 */
- (NSData* _Nullable)randomToken:(NSError* _Nullable* _Nullable)error;
/**
 * RandomTokenWith generates a random token with the given key size.
 */
- (NSData* _Nullable)randomTokenWith:(long)size error:(NSError* _Nullable* _Nullable)error;
/**
 * SymmetricKeyPacketWithPassword encrypts the session key with the password and
returns a binary symmetrically encrypted session key packet.
 */
- (NSData* _Nullable)symmetricKeyPacketWithPassword:(CryptoSymmetricKey* _Nullable)sessionSplit password:(NSString* _Nullable)password error:(NSError* _Nullable* _Nullable)error;
/**
 * UpdatePrivateKeyPassphrase decrypts the given armored privateKey with
oldPassphrase, re-encrypts it with newPassphrase, and returns the new armored
key.
 */
- (NSString* _Nonnull)updatePrivateKeyPassphrase:(NSString* _Nullable)privateKey oldPassphrase:(NSString* _Nullable)oldPassphrase newPassphrase:(NSString* _Nullable)newPassphrase error:(NSError* _Nullable* _Nullable)error;
/**
 * UpdateTime updates cached time
 */
- (void)updateTime:(int64_t)newTime;
@end

/**
 * Identity contains the name and the email of a key holder.
 */
@interface CryptoIdentity : NSObject <goSeqRefInterface> {
}
@property(strong, readonly) _Nonnull id _ref;

- (nonnull instancetype)initWithRef:(_Nonnull id)ref;
- (nonnull instancetype)init;
@property (nonatomic) NSString* _Nonnull name;
@property (nonatomic) NSString* _Nonnull email;
@end

/**
 * KeyRing contains multiple private and public keys.
 */
@interface CryptoKeyRing : NSObject <goSeqRefInterface> {
}
@property(strong, readonly) _Nonnull id _ref;

- (nonnull instancetype)initWithRef:(_Nonnull id)ref;
- (nonnull instancetype)init;
/**
 * FirstKeyID as obtained from API to match salt
 */
@property (nonatomic) NSString* _Nonnull firstKeyID;
/**
 * CheckPassphrase checks if private key passphrase is correct for every sub key.
 */
- (BOOL)checkPassphrase:(NSString* _Nullable)passphrase;
// skipped method KeyRing.Decrypt with unsupported parameter or return types

// skipped method KeyRing.DecryptArmored with unsupported parameter or return types

// skipped method KeyRing.DecryptMessage with unsupported parameter or return types

/**
 * DecryptMessageIfNeeded data if has armored PGP message format, if not return original data.
If error is errors.ErrSignatureExpired (from golang.org/x/crypto/openpgp/errors),
contents are still provided if library clients wish to process this message further.
 */
- (NSString* _Nonnull)decryptMessageIfNeeded:(NSString* _Nullable)data error:(NSError* _Nullable* _Nullable)error;
// skipped method KeyRing.Encrypt with unsupported parameter or return types

// skipped method KeyRing.EncryptArmored with unsupported parameter or return types

- (NSString* _Nonnull)encryptKey:(CryptoSymmetricKey* _Nullable)symKey error:(NSError* _Nullable* _Nullable)error;
/**
 * EncryptMessage encrypts and armors a string to the keyring's owner.
Wrapper of Encrypt.
 */
- (NSString* _Nonnull)encryptMessage:(NSString* _Nullable)s sign:(CryptoKeyRing* _Nullable)sign error:(NSError* _Nullable* _Nullable)error;
/**
 * EncryptSymmetric data using generated symmetric key encrypted with this KeyRing.
Wrapper of Encrypt.
 */
- (ModelsEncryptedSplit* _Nullable)encryptSymmetric:(NSString* _Nullable)textToEncrypt canonicalizeText:(BOOL)canonicalizeText error:(NSError* _Nullable* _Nullable)error;
/**
 * GetArmoredPublicKey returns the armored public keys from this keyring.
 */
- (NSString* _Nonnull)getArmoredPublicKey:(NSError* _Nullable* _Nullable)error;
// skipped method KeyRing.GetEntities with unsupported parameter or return types

/**
 * GetFingerprint gets the fingerprint from the keyring.
 */
- (NSString* _Nonnull)getFingerprint:(NSError* _Nullable* _Nullable)error;
/**
 * GetPublicKey returns the unarmored public keys from this keyring.
 */
- (NSData* _Nullable)getPublicKey:(NSError* _Nullable* _Nullable)error;
// skipped method KeyRing.GetSigningEntity with unsupported parameter or return types

// skipped method KeyRing.Identities with unsupported parameter or return types

// skipped method KeyRing.KeyIds with unsupported parameter or return types

/**
 * SignBinDetached creates an armored detached signature of binary data.
 */
- (NSString* _Nonnull)signBinDetached:(NSData* _Nullable)plainData passphrase:(NSString* _Nullable)passphrase error:(NSError* _Nullable* _Nullable)error;
/**
 * SignTextDetached creates an armored detached signature of a given string.
 */
- (NSString* _Nonnull)signTextDetached:(NSString* _Nullable)plainText passphrase:(NSString* _Nullable)passphrase trimNewlines:(BOOL)trimNewlines error:(NSError* _Nullable* _Nullable)error;
/**
 * Unlock tries to unlock as many keys as possible with the following password. Note
that keyrings can contain keys locked with different passwords, and thus
err == nil does not mean that all keys have been successfully decrypted.
If err != nil, the password is wrong for every key, and err is the last error
encountered.
 */
- (BOOL)unlock:(NSData* _Nullable)passphrase error:(NSError* _Nullable* _Nullable)error;
/**
 * UnmarshalJSON implements encoding/json.Unmarshaler.
 */
- (BOOL)unmarshalJSON:(NSData* _Nullable)b error:(NSError* _Nullable* _Nullable)error;
/**
 * VerifyBinDetachedSig verifies an armored detached signature given the plaintext as binary data.
 */
- (BOOL)verifyBinDetachedSig:(NSString* _Nullable)signature plainData:(NSData* _Nullable)plainData verifyTime:(int64_t)verifyTime ret0_:(BOOL* _Nullable)ret0_ error:(NSError* _Nullable* _Nullable)error;
/**
 * VerifyTextDetachedSig verifies an armored detached signature given the plaintext as a string.
 */
- (BOOL)verifyTextDetachedSig:(NSString* _Nullable)signature plainText:(NSString* _Nullable)plainText verifyTime:(int64_t)verifyTime trimNewlines:(BOOL)trimNewlines ret0_:(BOOL* _Nullable)ret0_ error:(NSError* _Nullable* _Nullable)error;
// skipped method KeyRing.WriteArmoredPublicKey with unsupported parameter or return types

// skipped method KeyRing.WritePublicKey with unsupported parameter or return types

@end

/**
 * Signature is be used to check a signature. Because the signature is checked
when the reader is consumed, Signature must only be used after EOF has been
seen. A signature is only valid if s.Err() returns nil, otherwise the
sender's identity cannot be trusted.
 */
@interface CryptoSignature : NSObject <goSeqRefInterface> {
}
@property(strong, readonly) _Nonnull id _ref;

- (nonnull instancetype)initWithRef:(_Nonnull id)ref;
- (nonnull instancetype)init;
/**
 * Err returns a non-nil error if the signature is invalid.
 */
- (BOOL)err:(NSError* _Nullable* _Nullable)error;
/**
 * IsBy returns true if the signature has been created by kr's owner.
 */
- (BOOL)isBy:(CryptoKeyRing* _Nullable)kr;
/**
 * KeyRing returns the key ring that was used to produce the signature, if
available.
 */
- (CryptoKeyRing* _Nullable)keyRing;
@end

/**
 * SignatureCollector structure
 */
@interface CryptoSignatureCollector : NSObject <goSeqRefInterface> {
}
@property(strong, readonly) _Nonnull id _ref;

- (nonnull instancetype)initWithRef:(_Nonnull id)ref;
- (nonnull instancetype)init;
// skipped method SignatureCollector.Accept with unsupported parameter or return types

/**
 * GetSignature collected by Accept
 */
- (NSString* _Nonnull)getSignature;
@end

/**
 * SignedString wraps string with a Signature
 */
@interface CryptoSignedString : NSObject <goSeqRefInterface> {
}
@property(strong, readonly) _Nonnull id _ref;

- (nonnull instancetype)initWithRef:(_Nonnull id)ref;
- (nonnull instancetype)init;
@property (nonatomic) NSString* _Nonnull string;
@property (nonatomic) CryptoSignature* _Nullable signed_;
@end

/**
 * SymmetricKey stores a decrypted session key.
 */
@interface CryptoSymmetricKey : NSObject <goSeqRefInterface> {
}
@property(strong, readonly) _Nonnull id _ref;

- (nonnull instancetype)initWithRef:(_Nonnull id)ref;
- (nonnull instancetype)init;
/**
 * The decrypted binary session key.
 */
@property (nonatomic) NSData* _Nullable key;
/**
 * The symmetric encryption algorithm used with this key.
 */
@property (nonatomic) NSString* _Nonnull algo;
/**
 * GetBase64Key returns the session key as base64 encoded string.
 */
- (NSString* _Nonnull)getBase64Key;
// skipped method SymmetricKey.GetCipherFunc with unsupported parameter or return types

@end

/**
 * DecryptAttKey decrypts a public-key encrypted session key and returns the
decrypted symmetric session key.
 */
FOUNDATION_EXPORT CryptoSymmetricKey* _Nullable CryptoDecryptAttKey(CryptoKeyRing* _Nullable kr, NSString* _Nullable keyPacket, NSError* _Nullable* _Nullable error);

// skipped function EncryptCore with unsupported parameter or return types


// skipped function FilterExpiredKeys with unsupported parameter or return types


/**
 * GetGopenPGP return global GopenPGP
 */
FOUNDATION_EXPORT CryptoGopenPGP* _Nullable CryptoGetGopenPGP(void);

// skipped function ReadArmoredKeyRing with unsupported parameter or return types


// skipped function ReadKeyRing with unsupported parameter or return types


// skipped function SeparateKeyAndData with unsupported parameter or return types


/**
 * SplitArmor is a helper method which splits an armored message into its
session key packet and symmetrically encrypted data packet.
 */
FOUNDATION_EXPORT ModelsEncryptedSplit* _Nullable CryptoSplitArmor(NSString* _Nullable encrypted, NSError* _Nullable* _Nullable error);

@class CryptoMIMECallbacks;

/**
 * MIMECallbacks defines callback methods to process a MIME message.
 */
@interface CryptoMIMECallbacks : NSObject <goSeqRefInterface, CryptoMIMECallbacks> {
}
@property(strong, readonly) _Nonnull id _ref;

- (nonnull instancetype)initWithRef:(_Nonnull id)ref;
- (void)onAttachment:(NSString* _Nullable)headers data:(NSData* _Nullable)data;
- (void)onBody:(NSString* _Nullable)body mimetype:(NSString* _Nullable)mimetype;
/**
 * Encrypted headers can be in an attachment and thus be placed at the end of the mime structure.
 */
- (void)onEncryptedHeaders:(NSString* _Nullable)headers;
- (void)onError:(NSError* _Nullable)err;
- (void)onVerified:(long)verified;
@end

#endif
